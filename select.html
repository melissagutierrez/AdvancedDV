<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Flot: Selecting Content 02</title>
    <link href="css/selecting-content.css" rel="stylesheet" />
  </head>

  <body>

    <!-- Now that we have structure in place and know our data is good,
    we can go ahead and build the interactive features into our chart.
    In this case, our user is given the option to turn on/off any lines
    drawn on the chart.
    This is ideal for when we have multiple data sets for comparing. A
    user may have an interest in one specific data set, but see how it
    relates to another. Further, by turning off other data sets, it
    allows a user to simplify the chart for more clarity. -->

    <div id="wrapper">
      <h1>Satisfaction with Financial Situation from 1975-2015</h1>
      <div id="chart"></div>

      <!-- We've removed our 'prototype' control - - we'll rebuild this
      using JavaScript/jQuery. But we have the previous file to use as
      our blueprint.
      We have left the description of what these controls do. -->

      <div id="controls">
        <p>Ages:</p>
        <form></form>
      </div>
    </div>

    <script src="js/jquery-3.3.1.min.js"></script>
    <script src="js/jquery.flot.min.js"></script>

    <script>
      // Because all is handled by jQuery, we place everything inside
      // our $(function() { }); (jQuery) structure.
      $(function() {
        // Our raw data:
        var eas =
        [[1975,27.4],[1980,21.5],[1985,23.5],[1990,27.8],[1995,21.8],[2000,23.9],[2005,24.4],[2010,20.8],[2015,23.9]];
        var ecs =
        [[1975,25.4],[1980,26.9],[1985,26.1],[1990,23.6],[1995,25.1],[2000,27.9],[2005,29.3],[2010,20.0],[2015,21.9]];
        var lcn =
         [[1975,37.5],[1980,31.0],[1985,35.9],[1990,35.0],[1995,31.6],[2000,37.7],[2005,29.7],[2010,19.1],[2015,30.0]];
        var mea =
        [[1975,42.8],[1980,42.7],[1985,41.1],[1990,43.0],[1995,46.7],[2000,43.1],[2005,44.4],[2010,39.9],[2015,42.7]];


        // Our data, organized in a series, with options for Flot:
        // A quick note about this data. In our previous example, it was
        // unorganized. The order of the legend and the lines did not
        // match. Whenever we're presenting information we want to
        // eliminate unnecessary thinking for our user. If the legend
        // and lines match up, we've made the chart easier for our user
        // to consume and understand quicker.
        // I believe there are options in Flot to allow you to format
        // the legend without having to re-arrange data. However,
        // because our set of data sets are so few, we can just make
        // this adjustment ourselves, let's do that. (The data sets
        // have been re-arranged in order of how they appear on the
        // chart so our legend will match.)
        var source = [
          {
            data: ecs,
            show: true,
            color: "#C1E4F6",
            label: "18-34"
          },
          {
            data: eas,
            show: true,
            color: "#82AEC4",
            label: "35-49"
          },
          {
            data: lcn,
            show: true,
            color: "#577685",
            label: "50-64"
          },
          {
            data: mea,
            show: true,
            color: "#1F3641",
            label: "65+",
          }
        ];
        // First, we need to draw the chart.
        // The .map() function is loop-like in that it iterates over
        // an array, but makes a change to the array item.
        // The .grep() function removes items from an array which
        // pass a test.
        // Here, we're testing our 'source' array to see if the 'show'
        // property is true. If so, return the data and color (which is
        // needed to show the line on the graph).
        // This code below builds the chart we initially see when the
        // page loads and stores all the data in a variable (plotObj)
        // which we'll modify in the future.
        var plotObj = $.plot($("#chart"),
          $.map(
            $.grep(source, function(obj) { return obj.show; }),
            // find (source, pattern)
            function(obj) { return { data: obj.data, color: obj.color }}
            // modify the array
          )
        );
        // Next, let's build our controls for the user. If you need to,
        // refer to the prototype we built in the previous example.
        // For each item in the 'source' array, we need to:
        // 1. Create a checkbox <input> for the user to toggle.
        //    Note we've added the index number to an id for each
        //    <input>. We'll need this later.
        // 2. If the region 'show' property is true, make sure
        //    the input's 'checked' attribute is true.
        // Building on a thought from class: "Why not include the
        // 'checked' attribute when we build the array?"
        // What if you don't want to show all data sets on load? You
        // may have some values which are 'show: false' and only appear
        // when a user explicitly sets this.
        // Another example would be to have no lines appear on initial
        // load, but have the chart build out through an animation. In
        // this case, all 'show' data (and checkboxes) would need to be
        // set to false, then changed incrementally.
        // But we digress...
        // 3. Build a <label> tag, appending our span (which contains
        //    the line color) and label.
        // 4. Append each <label> to our <form>.
        $.each(source, function(index, region) {
          var input = $("<input>").attr("type", "checkbox").attr("id","chk-" + index);
          if(region.show) {
            $(input).prop("checked", true);
          }
          var span = $("<span>").css({ "background-color": region.color });
          var label = $("<label>").append(input).append(span).append(region.label);
          $("#controls form").append(label);
        });
        // We now need to build the interaction.
        // When an <input> is clicked, the browser will return an
        // event. The event tells us which checkbox (the target) has
        // been clicked, i.e. chk-0, chk-1, etc.
        // The index variable takes the event target id and strips the
        // number from the end using the substr() method.
        // i.e. chk-0 --> '0'
        // We can then use this number to identify the data set in the
        // source array (i.e. source[0]) and target the 'show' property
        // in said set (i.e. source[0].show). We set this value to the
        // opposite of what already exists to create the toggle.
        // i.e. show: true --> show: false (or false --> true)
        // We then map these changes to the source array, creating
        // an array of data which only contains 'checked' items.
        $("input").click(function(event) {
          index = event.target.id.substr(4);
          source[index].show = !source[index].show;
          $.map(source, function(obj) {
            return { data: obj.data, color: obj.color };
          });
          // .map() will return a new version of source, where the
          // 'show' property in each data set will reflect whether
          // the checkbox is selected or not.
          // Makes some changes to the control, then view the console
          // to see this in action. Notice a box you have unchecked
          // now returns 'show: false'
          console.log(source);
          // Once we've created this modified array, we need to reset
          // the data being displayed on our chart. Remember, we have
          // contained this in plotObj. We can use this variable and
          // use setData() (a flot function) to apply these new changes.
          plotObj.setData(
            $.map(
              $.grep(source, function(obj) { return obj.show } ),
              function(obj) { return { data: obj.data, color: obj.color }; }
            )
          );
          // Once the data is (re)set, we redraw the chart.
          plotObj.draw();
        });
      });

    </script>

  </body>
</html>
